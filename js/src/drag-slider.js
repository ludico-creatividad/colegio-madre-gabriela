// Generated by CoffeeScript 1.7.1
(function() {
  var $, Slider, root;

  root = typeof window !== "undefined" && window !== null ? window : global;

  root.sliders = {};

  $ = root.jQuery;

  Slider = (function() {
    function Slider(sliderId, config) {
      var sliderItemWidth, _ref, _ref1, _ref10, _ref11, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
      this.sliderId = sliderId;
      if (config == null) {
        config = {};
      }
      $ = window.jQuery;
      this.settings = {
        viewportMaxWidth: (_ref = config.viewportMaxWidth) != null ? _ref : 1000,
        viewportMaxHeight: (_ref1 = config.viewportMaxHeight) != null ? _ref1 : 500,
        slideShow: (_ref2 = config.slideShow) != null ? _ref2 : true,
        stopOnHover: (_ref3 = config.stopOnHover) != null ? _ref3 : true,
        cycle: (_ref4 = config.cycle) != null ? _ref4 : true,
        navigator: (_ref5 = config.navigator) != null ? _ref5 : false,
        navigatorInParent: (_ref6 = config.navigatorInParent) != null ? _ref6 : false,
        navigatorEvents: (_ref7 = config.navigatorEvents) != null ? _ref7 : false,
        autoHideBtns: (_ref8 = config.autoHideBtns) != null ? _ref8 : true,
        duration: (_ref9 = config.duration) != null ? _ref9 : 1000,
        emmitEvents: (_ref10 = config.emmitEvents) != null ? _ref10 : false,
        draggable: (_ref11 = config.draggable) != null ? _ref11 : true
      };
      this.$sliderViewport = $('#' + sliderId);
      this.$slider = $(this.$sliderViewport.children('.slider'));
      this.$sliderItems = $(this.$slider.children('li'));
      this.$sliderPrevBtn = $(this.$sliderViewport.children('.prevBtn'));
      this.$sliderNextBtn = $(this.$sliderViewport.children('.nextBtn'));
      this.viewPortWidth = this.$sliderViewport.width();
      this.elementsQ = this.$sliderItems.length;
      this.sliderWidth = this.elementsQ * 100;
      sliderItemWidth = 100 / this.elementsQ;
      this.rightLimit = (this.viewPortWidth * this.elementsQ) - this.viewPortWidth;
      this.$slider.css('width', "" + this.sliderWidth + "%");
      this.$sliderItems.css('width', "" + sliderItemWidth + "%");
      this.index = 0;
      this.slideToPos = 0;
      this.draggedEl = null;
      this.hasLimitClass = false;
      if (this.settings.navigator) {
        this.addNavigator();
      }
      this.$sliderPrevBtn.click((function(_this) {
        return function(e) {
          e.stopPropagation();
          return _this.slideTo('prev');
        };
      })(this));
      this.$sliderNextBtn.click((function(_this) {
        return function(e) {
          e.stopPropagation();
          return _this.slideTo('next');
        };
      })(this));
      this.$sliderNavBtns.mousedown((function(_this) {
        return function(e) {
          var index;
          e.stopPropagation();
          index = $(e.currentTarget).index();
          return _this.slideTo(index);
        };
      })(this));
      if (this.settings.draggable) {
        this.$sliderViewport.mousedown((function(_this) {
          return function(e) {
            e.stopPropagation();
            e.preventDefault();
            return _this.dragStart(e);
          };
        })(this));
        $(document).mouseup((function(_this) {
          return function(e) {
            e.stopPropagation();
            e.preventDefault();
            return _this.dragEnd(e);
          };
        })(this));
      }
    }

    Slider.prototype.addNavigator = function() {
      var i, navigatorHtml, _i, _ref;
      navigatorHtml = '<ul class="navigator">';
      navigatorHtml += '<li class="navBullet selectedBullet"></li>';
      for (i = _i = 1, _ref = this.elementsQ; 1 <= _ref ? _i < _ref : _i > _ref; i = 1 <= _ref ? ++_i : --_i) {
        navigatorHtml += '<li class="navBullet"></li>';
      }
      navigatorHtml += '</ul>';
      this.$sliderViewport.append(navigatorHtml);
      if (this.settings.navigatorInParent) {
        return this.$sliderNavBtns = $(this.$sliderViewport.parent().find('.navigator a'));
      } else {
        return this.$sliderNavBtns = $(this.$sliderViewport.children('.navigator').children());
      }
    };

    Slider.prototype.dragStart = function(e) {
      var $el, startX;
      $el = $(e.currentTarget);
      this.dragStartX = e.pageX;
      startX = e.pageX;
      this.draggedEl = e.currentTarget;
      this.slideToPos = this.$slider.position().left;
      this.$slider.stop();
      return $el.on('mousemove', (function(_this) {
        return function(ev) {
          var offsetX;
          offsetX = startX - ev.pageX;
          startX = ev.pageX;
          _this.slideToPos -= offsetX;
          if (_this.slideToPos >= 0) {
            _this.slideToPos = 0;
            _this.isOutBounds = true;
            _this.dragStartX = startX;
            if (!_this.hasLimitClass) {
              _this.$sliderViewport.addClass('onLeftLimit');
              _this.hasLimitClass = true;
            }
          } else if (_this.slideToPos <= -_this.rightLimit) {
            _this.slideToPos = -_this.rightLimit;
            _this.isOutBounds = true;
            _this.dragStartX = startX;
            if (!_this.hasLimitClass) {
              _this.$sliderViewport.addClass('onRightLimit');
              _this.hasLimitClass = true;
            }
          }
          _this.$slider.css('left', _this.slideToPos + 'px');
          _this.isOutBounds = false;

          /*
          We should use a better way to move the elements around, using forced gpu calcs
          @$slider.css({
            '-webkit-transform': "translate3d(#{@slideToPos}%, 0px, 0px) perspective(2000px)"
          })
           */
          return null;
        };
      })(this));
    };

    Slider.prototype.dragEnd = function(e) {
      var minToAction, offsetPercentage, offsetX, tempIndex;
      if (!((this.draggedEl == null) || this.clicked)) {
        if (this.hasLimitClass) {
          this.$sliderViewport.removeClass('onLeftLimit onRightLimit');
          this.hasLimitClass = false;
        }
        offsetX = this.dragStartX - e.pageX;
        offsetPercentage = Math.abs(offsetX / this.viewPortWidth);
        minToAction = 0.1;
        if (offsetPercentage < minToAction) {
          offsetPercentage = 0;
        }
        if (offsetX > 0 && !this.isOutBounds) {
          tempIndex = this.index + Math.ceil(offsetPercentage);
        } else if (offsetX < 0 && !this.isOutBounds) {
          tempIndex = this.index - Math.ceil(offsetPercentage);
        } else {
          tempIndex = this.index;
        }
        this.slideTo(tempIndex);
        $(this.draggedEl).off('mousemove');
        this.draggedEl = null;
        return false;
      }
    };


    /*
     * Moves the slider to the prev, next, or an specific position based on the command argument
     * @param {string}|{integer} command
     * @return {void}
     */

    Slider.prototype.slideTo = function(command) {
      var err, lastIndx, selectedClass;
      this.clicked = null;
      switch (command) {
        case 'next':
          this.index++;
          break;
        case 'prev':
          this.index--;
          break;
        case 'first':
          this.index = 0;
          break;
        case 'last':
          this.index = this.elementsQ - 1;
          break;
        default:
          if (isFinite(command)) {
            this.index = command;
          } else {
            err = 'Please provide a valid command for the slider [prev,next or a valid index]';
            console.error(err);
            return false;
          }
      }
      lastIndx = this.elementsQ - 1;
      if (this.index > lastIndx) {
        if (this.settings.cycle) {
          this.index = 0;
        } else {
          this.index = lastIndx;
          return false;
        }
      } else if (this.index < 0) {
        if (this.settings.cycle) {
          this.index = lastIndx;
        } else {
          this.index = 0;
          return false;
        }
      }
      this.slideToPos = -1 * (this.index * 100);
      if (this.settings.navigator) {
        selectedClass = 'selectedBullet';
        this.$sliderNavBtns.removeClass(selectedClass);
        $(this.$sliderNavBtns[this.index]).addClass(selectedClass);
      }
      this.$slider.stop().animate({
        'left': this.slideToPos + '%'
      }, this.settings.duration);
      if (this.settings.emmitEvents) {
        return $.event.trigger('onSlide', [this.index, this.sliderId]);
      }

      /*
      @$slider.stop().css({
        '-webkit-transform': "translate3d(#{@slideToPos}%, 0px, 0px) perspective(2000px)"
      })
       */
    };

    return Slider;

  })();

  $(function() {
    return sliders.main = new Slider('mainSlider', {
      autoHideBtns: true,
      emmitEvents: true,
      navigator: true
    });
  });

}).call(this);

//# sourceMappingURL=drag-slider.map
